# FAQ

На этой странице мы собираем часто возникающие вопросы по БЭМ-методологии и отвечаем на них:

* + [Почему в БЭМ используются классы для CSS, а не любой другой тип селекторов](#bem-css-class)
* + [Почему не существует элементов элементов](bem-elem-elem)
* [Почему модификатор не может использоваться без указания его владельца]()
* + [Почему один модификатор не может применяться одновременно и к блоку, и к элементу]()
* [В каком случае создавать блок, в каком элемент]()
* []()
* [Не нашли ответ? Задайте вопрос команде на форуме](https://ru.bem.info/forum/)

## Почему в БЭМ используются селекторы класса для CSS-правил?

Соблюдение [соглашения по именованию](/naming/naming.ru.md) и использование CSS-классов позволяет реализовать основные принципы методологии БЭМ — независимость блоков и их повторное применение.

Имена БЭМ-сущностей и CSS-классы сопоставляются следующим образом:

* Каждой БЭМ-сущности назначается уникальное имя (смотри [соглашение по именованию](/naming/naming.ru.md)).
* Каждая БЭМ-сущность имеет CSS-класс, соответсвующий ее имени.

Такой подход позволяет создавать, изменять, переопределять CSS-свойства независимо для каждой БЭМ-сущности. Это дает возможность перемещать блоки по странице, повторно использовать, вкладывать один блок в другой и использовать [миксы](/definitions/definitions.ru.md#mix) без изменений их CSS-правил.

**Почему не id**

Селектор **id** может быть задан только уникальному блоку на странице. Это противоречит принципу БЭМ-методологии — все блоки должны иметь возможность использоваться повторно.

Гарантировать уникальность блока на странице нельзя. Блок поиска (`search`) долгое время был уникален.

HTML
```html
<div id="search"> ... </div>
```

CSS
```css
#search { ... }
```

Однако было решено продублировать блок поиска внизу страницы для удобства повторного поискового запроса.

Создавать правила, опираясь на id блока стало невозможным:

HTML

```html
<div class="search"> ... верхняя форма поиска ... </div>
...
<div class="search"> ... нижняя форма поиска ... </div>
```

CSS
```css
.search { ... }
```

**Почему не селекторы типа**

Селектор типа представляет собой название типа HTML-элемента и может определять CSS-правила к блоку без добавления класса. Классы в таком случае используются только для указания модификаторов.

HTML
```html
<block class="block_mod"/>
```

>[Почему не рекомендуется использовать имя модификатора без неймспейса в виде имени блока](#bem-mod-usage)

Использование селектора типа для определения блока не позволяет повторно применить блок на странице. Для этого необходимо как-то разделить CSS-правила, сделать блоки независимыми. Используя правила, созданные для HTML-тега, сделать это невозможно. Чтобы решить проблему, необходимо добавить имя блока к классу.

HTML
```html
<block class="block block_mod">
```

Сравним с классическим подходом БЭМ:

HTML
```html
<div class="block block_mod">
```

Сложность и длина записи одинаковы.

Использование кастомных тегов не поддерживает все разнообразие блоков. Например, все ссылки (блок `link`) в HTML всегда будут записаны как тег `<a>`.

<a name="bem-elem-hierarchy"></a>
## Почему не существует элементов элементов (`block__elem1__elem2`)

>В объяснении приводятся названия БЭМ-сущностей, основанные на [соглашении по именованию БЭМ](/naming/naming.ru.md).

В БЭМ-методологии вложенную структуру поддерживают только блоки (`block__elem`). Имя блока обеспечивает пространство имен, которое гарантирует зависимость элементов только от блока.

В DOM-дереве блок может иметь вложенную структуру элементов:

HTML
```html
<div class='block'>
    <div class='block__elem1'>
        <div class='block__elem2'>
            <div class='block__elem3'></div>
        </div>
    </div>
</div>
```

Однако эта же структура блока в БЭМ-методологии всегда будет представлена плоским списком элементов:

CSS
```css
.block{}
.block__elem1{}
.block__elem2{}
.block__elem3{}
```

Это позволяет изменять DOM-структуру блока без внесения правок в CSS-код каждого отдельного элемента.

HTML
```html
<div class='block'>
    <div class='block__elem1'>
        <div class='block__elem2'></div>
    </div>
    <div class='block__elem3'></div>
</div>
```

<a name="bem-mod-usage"></a>
## Почему модификатор не может использоваться без указания владельца

БЭМ-методология рекомендует использовать полное имя модификатора с указанием имени блока в качестве неймспеса: `<div class="block block_mod">`.

Комбинирование селекторов `.block.mod` дает полное представление о сущности, к которой написаны CSS-правила. Однако запись модификаторов без указания в префиксе имени блока `<div class="block mod">` имеет ряд недостатков.

**Неоднозначность**

В методологии БЭМ распространено использование [миксов](/definitions/definitions.ru.md#mix) — размещение нескольких БЭМ-сущностей на одной DOM-ноде. Использование модификатора без указания неймспейса в случае микса не дает гарантий, что модификатор применится к нужной БЭМ-сущности.

Например, рассмотрим микс пункта меню (`menu__item`) и кнопки (`button`).

HTML
```html
<div class="menu__item button"></div>
```

Добавим модификатор `active`:

HTML
```html
<div class="menu__item button active"></div>
```
В этом случае применение модификатора отразится на обоих БЭМ-сущностях.

По такой записи невозможно определить относится ли данный модификатор к пункту меню (`menu__item.active`) или к кнопке (`button.active`). Наличие неймспейса в виде имени блока явно указывает, к какой БЭМ-сущности будет применен модификатор: `button_active`.

Рассмотрим следующую запись:

HTML
```html
<div class="menu box">
```

Имя БЭМ-сущности не всегда явно указывает на ее суть. В такой форме записи не ясно, является ли данный пример миксом двух блоков или миксом блока и модификатора.

Наличие неймспейса решает эту проблему:

HTML
```html
<div class="menu menu_box">
```

**Специфичность селекторов**

Чем выше специфичность селектора, тем выше его приоритет.
Комбинированные селекторы имеют более высокую специфичность в CSS, чем одиночные. Использование модификатора без указания неймспейса в виде имени блока может вызвать трудности при переопределении CSS-свойств блока.

Предположим, существует такой блок кода:

HTML
```html
<div class="header">
  <button class="button active">
</div>
```

Если в проекте уже есть стили для `.button.active`, правила для переопределения кнопки могут иметь такой вид: `.header .button`. Специфичность `.button.active` и `.header .button` одинакова. Это значит, что применение CSS-правил будет зависеть только от порядка их объявления в декларации.

Применение классического подхода БЭМ `<div class="block block_mod">` обеспечивает более высокий приоритет правилам при переопределении блока. Селектор `.header .button` всегда будет иметь приоритет выше, чем `.button_active`.

**Сложность поиска данных**

Применение именования БЭМ делает файловую структуру проекта понятной и однозначной. Полные имена БЭМ-сущностей явно дают понять, о какой сущности идет речь.

Результаты поиска по проекту дадут точечный результат при введении полного имени БЭМ-сушности.

>Разница в записи `.block.mod` и `.block_mod` заключается в одном символе и всех преимуществах, перечисленных выше.

## Почему один модификатор не может применяться одновременно и к блоку, и к элементу

Объяснение обязательного наличия неймспейса в имени модификатора раскрыто в вопросе [Почему модификатор не может использоваться без указания владельца](#bem-mod-usage).

Независимость блоков обеспечивается их уникальными CSS-правилами, созданными отдельно для каждой БЭМ-сущности.

Так, следующее представление модификатора будет недействительным:

`block_bloc-mod__elem_elem-mod`

Такая форма записи не дает возможности использовать [миксы](./definitions/definitions.ru.md#mix) — размещение нескольких БЭМ-сущностей на одном DOM-узле.

## В каком случае создавать блок, в каком элемент

Разделение на блоки и элементы в БЭМ-методологии условно. В «идеальном мире» блок всегда абсолютно независимый компонент страницы, а элемент — часть блока, которая не может использоваться все контекста блока.

Однако, иногда некоторые элементы целесообразно выделить в отдельный блок для удобства работы с ними. Элемент может быть реализован как служебный блок, если:

* Он предоставляет большую, сложную функциональность.
* Существует необходимость создать вложенные элементы.
